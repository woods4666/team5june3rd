## 临毕业摸底测验（第一部分）
### JavaScript （前端玩家必备技能）
1. ele.getAttribute('propName') 和 ele.propName区别
   >  e.propName通常是在HTML文档中访问特定元素的特性，浏览器解析元素后生成对应对象（如a标签生成HTMLAnchorElement），这些
    对象的特性会根据特定规则结合属性设置得到，对于没有对应特性的属性，只能使用getAttribute进行访问

   e.getAttribute()返回值是源文件中设置的值，类型是字符串或者null（有的实现返回""）
    e.propName返回值可能是字符串、布尔值、对象、undefined等


2. mouseover和mouseenter的区别
   > mouseover是不管指针穿越元素或者子元素都会触发这个事件
   > mouseenter是只有指针经过被选元素才会触发事件


3. 什么是事件代理
   > 利用事件的冒泡传播机制,如果一个容器的后代元素中,很多元素的点击行为(其他事件行为也是)都要做一些处理,此时我不需要在向以前一样一个个获取一个个绑定了,我们只需要给容器的click绑定方法即可,这样不管是点击的是哪一个后代元素,都会根据冒泡传播的传递机制,把容器的click行为触发,把对应的方法执行,根据事件源,我们可以知道点击的是谁,从而做不同的事情即可



4. localStorage和cookie的区别，cookie和session的关系！

 > 



5. 什么是闭包，你在项目中哪一块用到了闭包！
    > 闭包是JS中一个非常重要的机制,我们很多编程思想,业务逻辑,设计模式都是基于闭包完成的,闭包就函数执行时产生的一和私有作用域(不销毁),在这个作用域中私有变量和外界互不干扰,而且作用域(栈)不销毁,这些私有变量存储的值也都保存下来了，所有整体来说闭包就是为了保护保存变量的

     实际项目开发中，很多地方使用到了闭包，例如：
    * 1、循环事件绑定，由于事件绑定是异步编程的，我们此时在循环的时候把索引存储起来（可以基于自定义属性存储，也可以基于闭包存储），后期需要使用的时候，向上级作用域查找使用即可
    * 2、平时做业务逻辑的时候，我一般都是基于单例模式来管理的代码的，这种单例的构建就应用到了闭包
```
let xxxRender=(function(){
    return {
        init:function(){
        }
    }
})();
xxxRender:init();
```

6. js中定义函数的方式有哪些，区别是什么！

> 


7. 说出你掌握的继承方式及优缺点，并加以改进！


8. 说出ES6和ES5的区别！
    > let /const
	 - 和ES5的区别： 
	- 1）、不存在变量提升机制（变量不允许在声明之前使用）
	- 2）、let不允许重复声明
	- 3）、在全局作用域中基于let声明的变量不是window的一个属性，和他没有关系
	- 4）、typeof 未被声明的变量， =>不是undefined而是报错（暂时性死去/）
	- 5）、let会形成块级作用域
- 解构赋值
- “...”拓展、剩余、展开运算符
- 箭头函数
	- 和普通函数的区别：
	- 1）、没有argument，但是可以基于...arg获取实参集合（结果是一个数组）
	- 2）、没有自己的this，箭头函数中的this是值上下文中的this

	- ES6中的模版字符串
	- promise（async/await）
	- class（ES6中创建类的）
	- interator（for of循环）
	- Map/Set




9. 阐述JS中的同步编程和异步编程，以及你在项目中是如何来使用异步操作的！
    > > - `同步编程`：任务是按照顺序依次处理，当这件事没有彻底做完，下一件事是执行不了的,在一个线程上（主栈/主任务队列）同一个时间只能做一件事情，当前事件完成才能进行下一个事情（先把一个任务进栈执行，执行完成，再把下一个任务进栈，上一个任务出栈）
    > - `异步编程`：当这件事没有彻底昨晚，需要等待一段时间才能继续处理，此时我们不等，继续执行下面的任务，当后面的任务完成后，再去把没有彻底完成的事情完成。
    > 在主栈中执行一个任务，但是发现这个任务是一个异步操作，我们会把它移除主栈，放到等待任务队列中（此时浏览器会分配其它线程监听异步任务是否达到指定的时间），如果主栈执行完成，监听者会把到达时间的异步任务重新放到主栈任务中执行….

-  JS中的异步编程：
    -  1、所有的事件都是异步编程
    -  2、所有定时器都是异步编程 setTimeout(function(){},100)
    - 3、AJAX中一般都是使用异步编程处理
    - 4、回调函数也算是异步编程

10. 实现一个Promise

### HTTP && AJAX && 跨域 （18+玩家必备技能，初级玩家需要了解一些的）
1. 写出项目中经常用到的性能优化方案
 > `1.在JS中尽量减少闭包的使用（原因：会产生不释放的栈内存）`
- 1）循环给元素做时间绑定的时候，尽可能的把后期需要的信息（例如索引）存储到元素的自定义属性上，而不是创建闭包存储
 - 2）可以在最外层形成一个闭包，把一些后续需要的公共信息进行存储，而不是每一个方法都创建一个闭包（例如单例模式）
- 3）尽可能的手动释放不被占用的内存
`2.尽量合并css和js文件（把需要引入的css 合并为一个，js也合并为一个，减少http次数，尽可能的把合并后的代码进行压缩，减小http请求资源的大小）`
- 1）webpack这种自动化共建工具，可以帮我们实现代码的合并和压缩（工程化开发）
- 2）在移动端开发（或者高性能的pc端开发[例如百度首页]），如果css或者js不是需要很多，我们可以选择把css和js编程内嵌式（也就是代码直接写在HTML中）

 `4.减少DOM的操作（主要是减少DOM的重绘和回流（重排））`
- 1）关于重排的分离读写
- 2）使用文档碎片或这字符串拼接做数据绑定（DOM的动态创建）

`6.尽可能使用时间委托（时间代理）来处理事件绑定的操作`，减少DOM的频繁操作，其中包括给每一个DOM元素做事件绑定

2. 从浏览器地址栏输入URL到显示页面，中间都经历了什么（尽可能写详细，最好回答出TCP的三次握手和四次挥手，以及浏览器加载页面的细节）

    >- 1、首先，在浏览器地1、首先，在浏览器地址栏中输入url
    >- 2、浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，直接域名解析
    >- 3、浏览器首先向DNS域名解析服务器发送请求
    >- 4、DNS反解析：根据浏览器请求地址中的域名到DNS服务器中找到对应的服务器外网IP地址
    >- 5、浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。（TCP即传输控制协议。TCP连接是互联网连接协议集的一种。）
    >- 6、握手成功后，浏览器向服务器发送http请求，请求数据包。
    >- 7、通过URL地址中携带的端口号找到服务器上对应的服务，以及服务所管理的项目源文件
    >8、服务器端根据请求地址中的路径名称，问号传参，或者哈希值，把客户端需要的内容进行准备和处理并返回给客户端
    >- 客户端浏览器接收到服务器返回的源代码，基于自己内部的渲染引擎（内核）开始进行页面的绘制和渲染


3. 说出你所熟知的HTTP状态码！GET和POST有啥区别！
    > - ` 200 OK 成功`（只能证明服务器成功返回信息了，但是信息不一定是你业务需要的）
    - `301 Moved Permanently 永久转移`（永久重定向=>307）
        - 域名更改，访问原始域名重定向到新的域名

    - `302 临时转移`（临时重定向 => 307）
        - 网站现在是基于HTTP协议运作的，如果访问的是HTTP协议，会基于307重定向到HTTPS协议上
    - `307  临时重定向 `
    - ` 302 一般用作服务器负载均衡`：当一台服务器达到最大并发送的时候，就把后续访问的用户临时转移到其它的服务器机组上处理
        - 偶尔真实项目中会把所有的图片放到单独的服务器上“图片处理服务器”，这样减少主服务器的压力，当用户向主服务器当问图片的时候，主服务器都把它转移到图片服务器上处理

    - `304 Not Modified 设置缓存`
    - 对于不经常更新的资源文件，例如：CSS/JS /HTML/IMG等，服务器会结合客户端设置304缓存，第一次加载付哦这些资源就缓存到客户端了，下次在获取的时候，是从缓存中获取；如果资源更新了，服务器端会通过最后修改时间来强制让客户端行从服务器重新拉取；基于CTRL+F5强制刷新页面，304做的缓存就没有用了。

    - `400 Bad Required`  请求参数错误
    - ` 401 Unauthorized`无权限访问
    - ` 404 Not Found` 找不到资源（地址不存在）
    - `413 Request Entity Too Large`  和服务器交互的内容资源超过服务器最大限制
    - ` 500 Internal Server Error` 未知的服务器错误
    - `503 Service Unavailable` 服务器超负荷
    **get VS post区别**
    区别：传递给服务器信息的方式不一样
    - get：是基于url地址**“问号传参**的方式把信息传递给服务器
    - post：是基于**请求主体**把信息传递给服务器
        -	请求主体中传递给服务器的是JSON格式的字符串，但是真实项目中常用的是url-encode格式的字符串
    ```
    [get]
    xhr.open('get','temp/list?xxx=xxx&xxx=xxx')

    [post]
    xhr.send('xxx=xxx&xxx=xxx')
    get 一般应用于拿（给服务器的会少一些），而post给服务器的很多，如果post是基于问号传参的方式来搞会出现一些问题：URL会拼接很长，浏览器对于URL的长度，都有点最大限度
    （谷歌8kb 火狐7kb IE2kb），超过的部分浏览器就把它截掉了 =>所以get请求可以基于URL传参，而post都是使用请求主体传递（请求主体理论上是没有限制的，但是真实项目中我们会自己做大小限制，防止上传过大信息导致请求迟迟完不成）
    ```
    `[get不安全，post相对安全]`
    - 因为get是基于“问号传参”把信息传递给服务器的，容易被骇客进行URL劫持
    - post：是基于请求主体传递的，相对来说不好被劫持；所以登陆、注册等涉及安全性的交互操作，我们都应该用post请求；

    `[get 会产生不可控制的缓存，post不会]`
    - **不可控**：不是想要就要，想不要就不要的，这是浏览器自主记忆，我们无法基于JS控制，真实项目中我们都会把这个缓存干掉
    - **get请求缓存是因为**：连续多次向相同的地址（并且传递的参数信息也是相同的）发送到请求，浏览器会把之前获取的数据从缓存中拿到返回，导致无法获取服务器最新的数据（post不会）

    `[get的缓存 解决方案]`
    ```
    xhr.open('get',`temp/list?lx=1000&_=${Math.random()}`);//保证每次请求地地址不完全一致：在每一次请求的末尾追加一个随机数即可（使用_作为属性名就是不想和其它的属性名冲突）
    ```

4. 什么是HTTP报文，你熟知的报文都有哪些！
    >- `在客户端向服务器发送请求，以及服务器把内容响应给 客户端的时候，中间相互传递了很多内容（客户端把一些内容传递给服务器，服务器把一些内容响应给客户端），我们把传递的内容统称为``报文`
    > 首部（头）：请求头、响应头、通用头
    > 起始行：请求起始行、响应起始行
    > 主体：请求主体、响应主体
    `General 通用头`



5. 能说下304具体怎样实现吗？
    >not modified 设置缓存 
 对于不经常更新的资源文件例如../js/html/img等，服务器会结合客户端设置304缓存，第一次加载过这些资源就缓存到客户端了，下次再获取的时候是从缓存中获取；如果资源更新了，服务器端会通过最后修改时间来强制让客户端从服务器重新拉取；基于CTRL+F5强制刷新页面，304做的缓存就没有用了

6. 跨域是什么？http协议中如何判断跨域？如何解决跨域问题？
    >跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器施加的安全限制。检查是否同源（域名、协议、端口都相同）来判断跨域。 
 解决方法：JSONP,代理，修改header

7. HTTP2具体内容？SDPY了解么？

    >HTTP2： 
 多路复用（即一个tcp/ip连接可以请求多个资源） 
 首部压缩（http头部压缩，减少体积） 
 二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量） 
 服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端） 
 请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。） 
 如果http2.0全面应用，很多http1.1中的优化方案就无需用到了（譬如打包成精灵图，静态资源多域名拆分等）

8. HTTPS如何实现？tsl/ssl是什么？对称加密、非对称加密在什么时候、对什么数据加密？

9. DNS劫持是什么？
    > DNS是Domain Name System的简写，即域名系统，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网。 
    DNS劫持就是你输入的网址明明是Google.com出来的是baidu的页面


10. 封装一个AJAX库！

